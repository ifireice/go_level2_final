# Что сделано:
1. Дописан `-fs real` по аналогии с `mock`, что бы было однотипно.
2. Дописать дефолтное поведение для `-fs` (так оно уже и так есть в данном коде:
```var fsKind = flag.String("fs", "real", "file system: mock or real")``` только поменял с mock на real. 
Или что-то другое подразумевалось?).
3. Дубликаты - файлы с одинаковым именем, в тз немного другое под дубликатом понимается. 
Добавил еще проверку на размер файлов, теперь дубликаты - файлы с одинаковым именем и размером.
4. Программа компилируется (проверил)
5. Программа выполняет функциональность, описанную в задании.
6. Программа обладает флагом “-h/--help” для краткого объяснения функциональности. 
Конечно обладает, это же автоматически формируется, правда в информации только расшифровка флага -fs.
7. Программа должна уведомлять пользователя об ошибках, возникающих во время выполнения. 
Выполнено, добавлена ошибка ErrFaildToDeleteFile если возникают проблемы с удалением "реального" файла (а не "виртуального" как в mock).
8. Написать программу которая по случайному принципу генерирует копии уже имеющихся файлов, относительно указанной директории - сделал по другому. 
Написал программу которая генерирует папки и файлы, которые могут дублироваться (находится generateDirFile/generate.go)
9. Добавить тесты. Тест смог только 1 придумать на поиск дубликатов.

# Что не сделалано:
* При желании, распараллелить обход директорий
* При желании, распараллелить удаление файлов
* Сравнить производительность программы в однопоточном и многопоточном режимах

# Скелет для финальной задачи
Написан код для mock
Запуск
```bash
$ go run cmd/cli/main.go                                                                     
Enter directory path:
/mock

Found files:
...
```

Что бы запустить на реальной fs
```bash
$ go run cmd/cli/main.go  -fs real    
```

##TODO
* Дописать `-fs real`
* Дописать дефолтное поведение для `-fs`
* Дубликаты - файлы с одинаковым именем, в тз немного другое под дубликатом понимается
* Добавить тесты
* При желании, распараллелить обход директорий
* При желании, распараллелить удаление файлов

## Формулировка задачи
В качестве завершающего задания нужно выполнить программу поиска дубликатов файлов.

Дубликаты файлов - это файлы, которые совпадают по имени файла и по его размеру.

Нужно написать консольную программу, которая проверяет наличие дублирующихся
файлов.

Программа должна работать на локальном компьютере и получать на вход путь до
директории. Программа должна вывести в стандартный поток вывода список дублирующихся
файлов, которые находятся как в директории, так и в поддиректориях директории,
переданной через аргумент командной строки. Данная функция должна работать
эффективно при помощи распараллеливания программы

Программа должна принимать дополнительный ключ - возможность удаления обнаруженных
дубликатов файлов после поиска. Дополнительно нужно придумать, как обезопасить
пользователей от случайного удаления файлов. В качестве ключей желательно
придерживаться общепринятых практик по использованию командных опций.

### Критерии приемки программы:
1. Программа компилируется
2. Программа выполняет функциональность, описанную выше.
3. Программа покрыта тестами
4. Программа содержит документацию и примеры использования
5. Программа обладает флагом “-h/--help” для краткого объяснения функциональности
6. Программа должна уведомлять пользователя об ошибках, возникающих во время
   выполнения
   
### Дополнительно можете выполнить следующие задания:
1. Написать программу которая по случайному принципу генерирует копии уже
   имеющихся файлов, относительно указанной директории
2. Сравнить производительность программы в однопоточном и многопоточном режимах
